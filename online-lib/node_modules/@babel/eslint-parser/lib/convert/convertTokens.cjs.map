{"version":3,"names":["ESLINT_VERSION","require","convertTemplateType","tokens","tl","curlyBrace","templateTokens","result","addTemplateType","start","end","length","value","reduce","token","type","label","template","push","loc","forEach","backQuote","dollarBraceL","braceR","convertToken","source","range","name","semi","comma","parenL","parenR","braceL","slash","dot","bracketL","bracketR","ellipsis","arrow","pipeline","star","incDec","colon","question","at","logicalOR","logicalAND","nullishCoalescing","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","exponent","bang","tilde","doubleColon","hash","questionDot","braceHashL","braceBarL","braceBarR","bracketHashL","bracketBarL","bracketBarR","doubleCaret","doubleAt","isAssign","_token$value","jsxTagStart","jsxTagEnd","jsxName","jsxText","keyword","num","slice","string","regexp","regex","pattern","flags","bigint","privateName","templateNonTail","templateTail","rightAssociative","module","exports","convertTokens","code","templateTypeMergedTokens","i","tokenType","nextToken","column"],"sources":["../../src/convert/convertTokens.cjs"],"sourcesContent":["const ESLINT_VERSION = require(\"../utils/eslint-version.cjs\");\n\nfunction convertTemplateType(tokens, tl) {\n  let curlyBrace = null;\n  let templateTokens = [];\n  const result = [];\n\n  function addTemplateType() {\n    const start = templateTokens[0];\n    const end = templateTokens[templateTokens.length - 1];\n\n    const value = templateTokens.reduce((result, token) => {\n      if (token.value) {\n        result += token.value;\n      } else if (token.type.label !== tl.template) {\n        result += token.type.label;\n      }\n\n      return result;\n    }, \"\");\n\n    result.push({\n      type: \"Template\",\n      value: value,\n      start: start.start,\n      end: end.end,\n      loc: {\n        start: start.loc.start,\n        end: end.loc.end,\n      },\n    });\n\n    templateTokens = [];\n  }\n\n  tokens.forEach(token => {\n    switch (token.type.label) {\n      case tl.backQuote:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        templateTokens.push(token);\n\n        if (templateTokens.length > 1) {\n          addTemplateType();\n        }\n\n        break;\n\n      case tl.dollarBraceL:\n        templateTokens.push(token);\n        addTemplateType();\n        break;\n\n      case tl.braceR:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n        }\n\n        curlyBrace = token;\n        break;\n\n      case tl.template:\n        if (curlyBrace) {\n          templateTokens.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        templateTokens.push(token);\n        break;\n\n      default:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        result.push(token);\n    }\n  });\n\n  return result;\n}\n\nfunction convertToken(token, source, tl) {\n  const { type } = token;\n  const { label } = type;\n  token.range = [token.start, token.end];\n\n  if (label === tl.name) {\n    if (token.value === \"static\") {\n      token.type = \"Keyword\";\n    } else {\n      token.type = \"Identifier\";\n    }\n  } else if (\n    label === tl.semi ||\n    label === tl.comma ||\n    label === tl.parenL ||\n    label === tl.parenR ||\n    label === tl.braceL ||\n    label === tl.braceR ||\n    label === tl.slash ||\n    label === tl.dot ||\n    label === tl.bracketL ||\n    label === tl.bracketR ||\n    label === tl.ellipsis ||\n    label === tl.arrow ||\n    label === tl.pipeline ||\n    label === tl.star ||\n    label === tl.incDec ||\n    label === tl.colon ||\n    label === tl.question ||\n    label === tl.template ||\n    label === tl.backQuote ||\n    label === tl.dollarBraceL ||\n    label === tl.at ||\n    label === tl.logicalOR ||\n    label === tl.logicalAND ||\n    label === tl.nullishCoalescing ||\n    label === tl.bitwiseOR ||\n    label === tl.bitwiseXOR ||\n    label === tl.bitwiseAND ||\n    label === tl.equality ||\n    label === tl.relational ||\n    label === tl.bitShift ||\n    label === tl.plusMin ||\n    label === tl.modulo ||\n    label === tl.exponent ||\n    label === tl.bang ||\n    label === tl.tilde ||\n    label === tl.doubleColon ||\n    label === tl.hash ||\n    label === tl.questionDot ||\n    label === tl.braceHashL ||\n    label === tl.braceBarL ||\n    label === tl.braceBarR ||\n    label === tl.bracketHashL ||\n    label === tl.bracketBarL ||\n    label === tl.bracketBarR ||\n    label === tl.doubleCaret ||\n    label === tl.doubleAt ||\n    type.isAssign\n  ) {\n    token.type = \"Punctuator\";\n    token.value ??= label;\n  } else if (label === tl.jsxTagStart) {\n    token.type = \"Punctuator\";\n    token.value = \"<\";\n  } else if (label === tl.jsxTagEnd) {\n    token.type = \"Punctuator\";\n    token.value = \">\";\n  } else if (label === tl.jsxName) {\n    token.type = \"JSXIdentifier\";\n  } else if (label === tl.jsxText) {\n    token.type = \"JSXText\";\n  } else if (type.keyword === \"null\") {\n    token.type = \"Null\";\n  } else if (type.keyword === \"false\" || type.keyword === \"true\") {\n    token.type = \"Boolean\";\n  } else if (type.keyword) {\n    token.type = \"Keyword\";\n  } else if (label === tl.num) {\n    token.type = \"Numeric\";\n    token.value = source.slice(token.start, token.end);\n  } else if (label === tl.string) {\n    token.type = \"String\";\n    token.value = source.slice(token.start, token.end);\n  } else if (label === tl.regexp) {\n    token.type = \"RegularExpression\";\n    const value = token.value;\n    token.regex = {\n      pattern: value.pattern,\n      flags: value.flags,\n    };\n    token.value = `/${value.pattern}/${value.flags}`;\n  } else if (label === tl.bigint) {\n    token.type = \"Numeric\";\n    token.value = `${token.value}n`;\n  } else if (label === tl.privateName) {\n    token.type = \"PrivateIdentifier\";\n  } else if (label === tl.templateNonTail || label === tl.templateTail) {\n    token.type = \"Template\";\n  }\n\n  if (typeof token.type !== \"string\") {\n    // Acorn does not have rightAssociative\n    delete token.type.rightAssociative;\n  }\n}\n\nmodule.exports = function convertTokens(tokens, code, tl) {\n  const result = [];\n  const templateTypeMergedTokens = process.env.BABEL_8_BREAKING\n    ? tokens\n    : convertTemplateType(tokens, tl);\n  // The last token is always tt.eof and should be skipped\n  for (let i = 0, { length } = templateTypeMergedTokens; i < length - 1; i++) {\n    const token = templateTypeMergedTokens[i];\n    const tokenType = token.type;\n    if (tokenType === \"CommentLine\" || tokenType === \"CommentBlock\") {\n      continue;\n    }\n\n    if (!process.env.BABEL_8_BREAKING) {\n      // Babel 8 already produces a single token\n\n      if (\n        ESLINT_VERSION >= 8 &&\n        i + 1 < length &&\n        tokenType.label === tl.hash\n      ) {\n        const nextToken = templateTypeMergedTokens[i + 1];\n\n        // We must disambiguate private identifier from the hack pipes topic token\n        if (nextToken.type.label === tl.name && token.end === nextToken.start) {\n          i++;\n\n          nextToken.type = \"PrivateIdentifier\";\n          nextToken.start -= 1;\n          nextToken.loc.start.column -= 1;\n          nextToken.range = [nextToken.start, nextToken.end];\n\n          result.push(nextToken);\n          continue;\n        }\n      }\n    }\n\n    convertToken(token, code, tl);\n    result.push(token);\n  }\n\n  return result;\n};\n"],"mappings":"AAAA,MAAMA,cAAc,GAAGC,OAAO,CAAC,6BAA6B,CAAC;AAE7D,SAASC,mBAAmBA,CAACC,MAAM,EAAEC,EAAE,EAAE;EACvC,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAIC,cAAc,GAAG,EAAE;EACvB,MAAMC,MAAM,GAAG,EAAE;EAEjB,SAASC,eAAeA,CAAA,EAAG;IACzB,MAAMC,KAAK,GAAGH,cAAc,CAAC,CAAC,CAAC;IAC/B,MAAMI,GAAG,GAAGJ