'use strict';
const convertUnit = require('./convertUnit.js');

/**
 * @param {import('../parser').CalcNode} node
 * @return {node is import('../parser').ValueExpression}
 */
function isValueType(node) {
  switch (node.type) {
    case 'LengthValue':
    case 'AngleValue':
    case 'TimeValue':
    case 'FrequencyValue':
    case 'ResolutionValue':
    case 'EmValue':
    case 'ExValue':
    case 'ChValue':
    case 'RemValue':
    case 'VhValue':
    case 'VwValue':
    case 'VminValue':
    case 'VmaxValue':
    case 'PercentageValue':
    case 'Number':
      return true;
  }
  return false;
}

/** @param {'-'|'+'} operator */
function flip(operator) {
  return operator === '+' ? '-' : '+';
}

/**
 * @param {string} operator
 * @returns {operator is '+'|'-'}
 */
function isAddSubOperator(operator) {
  return operator === '+' || operator === '-';
}

/**
 * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible
 */

/**
 * @param {'+'|'-'} preOperator
 * @param {import('../parser').CalcNode} node
 * @param {Collectible[]} collected
 * @param {number} precision
 */
function collectAddSubItems(preOperator, node, collected, precision) {
  if (!isAddSubOperator(preOperator)) {
    throw new Error(`invalid operator ${preOperator}`);
  }
  if (isValueType(node)) {
    const itemIndex = collected.findIndex((x) => x.node.type === node.type);
    if (itemIndex >= 0) {
      if (node.value === 0) {
        return;
      }
      // can cast because of the criterion used to find itemIndex
      const otherValueNode = /** @type import('../parser').ValueExpression*/ (
        collected[itemIndex].node
      );
      const { left: reducedNode, right: current } = convertNodesUnits(
        otherValueNode,
        node,
        precision
      );

      if (collected[itemIndex].preOperator === '-') {
        collected[itemIndex].preOperator = '+';
        reducedNode.value *= -1;
      }
      if (preOperator === '+') {
        reducedNode.value += current.value;
      } else {
        reducedNode.value -= current.value;
      }
      // make sure reducedNode.value >= 0
      if (reducedNode.value >= 0) {
        collected[itemIndex] = { node: reducedNode, preOperator: '+' };
      } else {
        reducedNode.value *= -1;
        collected[itemIndex] = { node: reducedNode, preOperator: '-' };
      }